<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval'; script-src-attr 'unsafe-inline';" />
    <!-- Cache buster: PDF mode fix applied -->
    <title>RALPH MAG CHAT</title>
    <style>
      :root {
        --ralph-pink: #EB008B;
        --ralph-pink-light: #ff69b4;
        --ralph-pink-dark: #c7006e;
        --ralph-pink-bg: #fdeef7;
        --ralph-text: #1a1a1a;
        --ralph-gray: #f5f5f5;
        --ralph-border: #e0e0e0;
      }

      /* Global reset for images */
      img {
        border: none !important;
        outline: none !important;
        box-sizing: border-box;
      }

      body {
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        margin: 0; height: 100vh; display: flex;
        background: linear-gradient(135deg, #fce4ec 0%, #f8bbd9 100%);
      }

      .sidebar {
        width: 280px;
        background: linear-gradient(180deg, var(--ralph-pink) 0%, var(--ralph-pink-dark) 100%);
        color: white;
        padding: 20px 16px 16px 16px;
        box-shadow: 2px 0 10px rgba(235, 0, 139, 0.2);
        display: flex;
        flex-direction: column;
      }

      .logo-container {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid rgba(255,255,255,0.2);
      }

      .logo-container img {
        height: 36px;
        width: auto;
        margin-right: 12px;
        border-radius: 8px;
        background: white;
        padding: 6px;
        object-fit: contain;
      }

      .sidebar h1 {
        font-size: 18px;
        margin: 0;
        font-weight: 700;
        color: white;
        text-shadow: 0 1px 2px rgba(0,0,0,0.1);
      }

      .sidebar button, .sidebar a {
        display: block; width: 100%; margin: 6px 0; padding: 10px 12px;
        border: 0; border-radius: 8px; cursor: pointer; text-align: left;
        transition: all 0.2s ease; text-decoration: none;
      }

      .sidebar button {
        background: rgba(255,255,255,0.15);
        color: white;
        backdrop-filter: blur(10px);
        font-family: inherit;
        font-size: 14px;
        font-weight: 500;
      }

      .sidebar button:hover {
        background: rgba(255,255,255,0.25);
        transform: translateY(-1px);
      }

      .sidebar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .sidebar a {
        background: rgba(255,255,255,0.1);
        color: white;
        font-size: 13px;
        border: 1px solid rgba(255,255,255,0.2);
      }

      .sidebar a:hover {
        background: rgba(255,255,255,0.2);
        transform: translateY(-1px);
      }

      /* Sidebar content spacer */
      .sidebar-spacer {
        flex: 1; /* Takes up all available space, pushing covers to bottom */
      }

      /* Covers row at bottom */
      .covers-row {
        display: flex;
        gap: 6px;
        margin-top: auto; /* Auto margin pushes to bottom */
        margin-bottom: 0 !important; /* Consistent with sidebar padding */
        margin-left: 0 !important;
        margin-right: 0 !important;
        padding: 0 !important;
        justify-content: space-between;
        flex-wrap: nowrap;
        height: 100px; /* Fixed height for consistency */
        flex-shrink: 0; /* Prevent shrinking */
        width: 100%;
        box-sizing: border-box;
      }
      .covers-row a {
        flex: 1;
        display: block;
        height: 100%; /* Fill the container height */
        border: none !important;
        outline: none !important;
        text-decoration: none !important;
        box-shadow: none !important;
        padding: 0 !important;
        margin: 0 !important;
      }
      .cover-thumb {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 8px;
        border: none !important;
        outline: none !important;
        background: rgba(255,255,255,0.2);
        box-shadow: 0 3px 12px rgba(235, 0, 139, 0.3) !important;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
        vertical-align: top;
        display: block;
      }
      .cover-thumb:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(235, 0, 139, 0.35) !important;
      }

      .sidebar input {
        width: 100%; margin: 6px 0; padding: 10px 12px;
        border-radius: 8px; border: 1px solid rgba(255,255,255,0.3);
        background: rgba(255,255,255,0.1); color: white;
        backdrop-filter: blur(10px); font-size: 13px;
        transition: all 0.2s ease; font-family: inherit;
        box-sizing: border-box;
      }

      .sidebar input::placeholder {
        color: rgba(255,255,255,0.6);
      }

      .sidebar input:focus {
        outline: none;
        border-color: rgba(255,255,255,0.5);
        background: rgba(255,255,255,0.15);
        box-shadow: 0 0 0 2px rgba(255,255,255,0.1);
      }

      .sidebar .status-text {
        margin: 6px 0; font-size: 12px;
        color: rgba(255,255,255,0.8);
      }

      .sidebar .status-value {
        font-weight: 500;
        color: rgba(255,255,255,0.95);
      }

      .sidebar .section-title {
        margin: 12px 0 6px; font-size: 12px;
        color: rgba(255,255,255,0.9);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .sidebar .divider {
        border: 0; border-top: 1px solid rgba(255,255,255,0.2);
        margin: 16px 0; opacity: 0.6;
      }

      .sidebar .helper-text {
        display: block; margin-top: 6px;
        color: rgba(255,255,255,0.6);
        font-size: 11px; line-height: 1.3;
      }

      .collapse-toggle {
        background: rgba(255,255,255,0.1);
        color: rgba(255,255,255,0.9);
        border: 1px solid rgba(255,255,255,0.2);
        padding: 6px 10px; font-size: 12px;
        border-radius: 6px; cursor: pointer;
        transition: all 0.2s ease;
        display: flex; align-items: center; gap: 6px;
        margin-bottom: 12px; font-weight: 500;
      }

      .collapse-toggle:hover {
        background: rgba(255,255,255,0.2);
      }

      .collapse-toggle .icon {
        transition: transform 0.2s ease;
        font-size: 10px;
      }

      .collapse-toggle.collapsed .icon {
        transform: rotate(-90deg);
      }

      .setup-sections {
        overflow: hidden;
        transition: max-height 0.3s ease-out, opacity 0.2s ease;
        max-height: 1000px;
        opacity: 1;
      }

      .setup-sections.collapsed {
        max-height: 0;
        opacity: 0;
        margin: 0;
      }

      .history-sections {
        overflow: hidden;
        transition: max-height 0.3s ease-out, opacity 0.2s ease;
        max-height: 600px; /* show more items */
        opacity: 1;
        margin-bottom: 16px;
      }

      .history-sections.collapsed {
        max-height: 0;
        opacity: 0;
        margin: 0;
      }

      .history-list {
        max-height: 300px; /* show fewer items to make room for covers */
        overflow-y: auto;
        margin-bottom: 8px;
      }

      .history-item {
        padding: 8px 12px;
        margin: 4px 0;
        background: var(--ralph-pink-bg);
        border: 1px solid transparent;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 13px;
        line-height: 1.3;
        color: var(--ralph-text);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .history-item:hover {
        background: var(--ralph-pink-light);
        color: white;
        transform: translateX(2px);
      }

      .history-item-title {
        font-weight: 600;
        margin-bottom: 2px;
      }

      .history-item-time {
        font-size: 11px;
        opacity: 0.8;
      }

      .history-actions {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        margin-left: 8px;
      }

      .history-rerun {
        background: transparent;
        border: 1px solid var(--ralph-pink);
        color: var(--ralph-pink);
        border-radius: 4px;
        font-size: 11px;
        padding: 2px 6px;
        cursor: pointer;
      }
      .history-rerun:hover { background: var(--ralph-pink); color: white; }

      .no-history {
        text-align: center;
        color: #999;
        font-size: 12px;
        padding: 16px 8px;
        font-style: italic;
      }

      .clear-history-btn {
        width: 100%;
        padding: 6px 12px;
        background: transparent;
        border: 1px solid var(--ralph-pink);
        color: var(--ralph-pink);
        border-radius: 6px;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .clear-history-btn:hover {
        background: var(--ralph-pink);
        color: white;
      }

      /* Loading bar styles */
      .loading-container {
        background: rgba(255,255,255,0.1);
        border-radius: 8px;
        padding: 16px;
        margin: 16px 0 8px 0; /* More space above, less below */
        text-align: center;
      }

      .loading-bar {
        width: 100%;
        height: 6px;
        background: rgba(255,255,255,0.2);
        border-radius: 3px;
        margin: 8px 0;
        overflow: hidden;
      }

      .loading-progress {
        height: 100%;
        background: linear-gradient(90deg, var(--ralph-pink-light), white);
        border-radius: 3px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .loading-text {
        font-size: 12px;
        color: rgba(255,255,255,0.9);
        margin-bottom: 8px;
      }

      .sync-complete {
        color: rgba(255,255,255,0.9);
        font-size: 12px;
        padding: 8px;
        background: rgba(255,255,255,0.1);
        border-radius: 6px;
        margin: 8px 0;
      }

      .new-chat-btn {
        width: 100%;
        margin-bottom: 12px;
        padding: 8px 12px;
        background: var(--ralph-pink);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 600;
        font-size: 13px;
      }

      .new-chat-btn:hover {
        background: var(--ralph-pink-dark);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(235, 0, 139, 0.3);
      }

      .main {
        flex: 1;
        display: flex;
        flex-direction: row;
      }

      .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .messages {
        flex: 1;
        overflow-y: auto;
        padding: 24px;
        background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
      }

      .sources-panel {
        width: 320px;
        background: white;
        border-left: 1px solid var(--ralph-border);
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        opacity: 1;
        transition: opacity 180ms ease-in-out;
      }

      .sources-panel[style*="display: none"] {
        width: 0;
        padding: 0;
        border: none;
      }

      .sources-panel h3 {
        color: var(--ralph-pink);
        font-size: 16px;
        margin: 0 0 12px 0;
        padding-bottom: 8px;
        border-bottom: 2px solid var(--ralph-pink-bg);
      }

      .sources-panel.fading { opacity: 0.25; }

      /* Animate source item entries */
      .source-item { opacity: 1; transform: translateY(0); transition: opacity 220ms ease, transform 220ms ease; }
      .source-item.enter { opacity: 0; transform: translateY(6px); }
      .source-item.enter.enter-active { opacity: 1; transform: translateY(0); }

      .msg {
        max-width: 840px; margin: 0 auto 8px; padding: 16px 20px;
        border-radius: 16px; line-height: 1.6;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      }

      .msg.user {
        background: linear-gradient(135deg, var(--ralph-pink-bg) 0%, #f8bbd9 100%);
        border: 1px solid var(--ralph-pink-light);
        color: var(--ralph-text);
      }

      .msg.assistant {
        background: white;
        border: 1px solid var(--ralph-border);
      }

      /* Inline reading animation (slick bar) */
      .reading-container {
        position: relative;
        height: 6px;
        border-radius: 999px;
        background: #f0f0f0;
        overflow: hidden;
        margin: 4px 0 10px 0;
      }
      .reading-progress {
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg, rgba(235,0,139,0) 0%, rgba(235,0,139,0.35) 50%, rgba(235,0,139,0) 100%);
        background-size: 200% 100%;
        animation: readingSweep 1.1s linear infinite;
      }
      @keyframes readingSweep {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
      }
      .reading-hide { opacity: 0; transition: opacity 160ms ease; }

      /* Answer formatting styles with Ralph branding */
      .msg.assistant .summary {
        font-weight: 700;
        color: var(--ralph-pink-dark);
        margin-bottom: 8px;
        font-size: 18px;
        border-bottom: 2px solid var(--ralph-pink-bg);
        padding-bottom: 6px;
      }

      .msg.assistant ul { margin: 8px 0; padding-left: 0; list-style: none; }

      .msg.assistant li {
        margin: 6px 0; padding: 10px 16px;
        background: var(--ralph-pink-bg);
        border-left: 4px solid var(--ralph-pink);
        border-radius: 8px; position: relative;
        transition: all 0.2s ease;
      }

      .msg.assistant li:hover {
        background: #f8bbd9;
        transform: translateX(2px);
      }

      .msg.assistant li::before {
        content: "•";
        color: var(--ralph-pink);
        font-weight: bold;
        position: absolute;
        left: -8px;
        font-size: 18px;
      }

      .msg.assistant .quote {
        font-style: italic;
        color: var(--ralph-text);
        margin: 4px 0;
      }

      .msg.assistant .citation {
        background: var(--ralph-pink);
        color: white;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 13px;
        font-weight: 600;
        margin-left: 6px;
        box-shadow: 0 2px 4px rgba(235, 0, 139, 0.3);
        text-decoration: none;
        display: inline-block;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .msg.assistant .citation:hover {
        background: var(--ralph-pink-dark);
        transform: scale(1.05);
        box-shadow: 0 3px 6px rgba(235, 0, 139, 0.5);
      }

      .source-item.highlight {
        animation: highlightPulse 2s ease-out;
      }

      @keyframes highlightPulse {
        0% { background: var(--ralph-pink-light); transform: scale(1.02); }
        50% { background: var(--ralph-pink-bg); transform: scale(1.01); }
        100% { background: transparent; transform: scale(1); }
      }

      .msg.assistant blockquote {
        margin: 16px 0; padding: 16px 20px;
        background: var(--ralph-gray);
        border-left: 4px solid var(--ralph-pink-light);
        font-style: italic;
        color: var(--ralph-text);
        border-radius: 8px;
      }

      .msg.assistant p { margin: 6px 0; color: var(--ralph-text); }

      .msg.assistant .clarifier {
        margin-top: 20px; padding: 16px;
        background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
        border: 1px solid #ffb74d;
        border-radius: 10px;
        color: #e65100;
        font-size: 14px;
        box-shadow: 0 2px 8px rgba(255, 183, 77, 0.2);
      }

      .input {
        display: flex; gap: 12px; padding: 16px;
        border-top: 1px solid var(--ralph-border);
        background: white;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
      }

      .input textarea {
        flex: 1; resize: vertical; min-height: 52px; padding: 14px;
        font-size: 16px; border-radius: 12px;
        border: 2px solid var(--ralph-border);
        transition: border-color 0.2s ease;
      }

      .input textarea:focus {
        outline: none;
        border-color: var(--ralph-pink);
        box-shadow: 0 0 0 3px rgba(235, 0, 139, 0.1);
      }

      .input button {
        padding: 14px 20px; font-size: 16px; border: 0;
        border-radius: 12px;
        background: linear-gradient(135deg, var(--ralph-pink) 0%, var(--ralph-pink-dark) 100%);
        color: white; cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
        box-shadow: 0 4px 12px rgba(235, 0, 139, 0.3);
      }

      .input button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(235, 0, 139, 0.4);
      }

      .source-item {
        margin-bottom: 10px;
        padding: 12px;
        background: var(--ralph-pink-bg);
        border-radius: 8px;
        font-size: 13px;
        line-height: 1.5;
        border: 1px solid transparent;
        transition: all 0.2s ease;
      }

      .source-item:hover {
        background: white;
        border-color: var(--ralph-pink);
        transform: translateX(-2px);
        box-shadow: 0 2px 4px rgba(235, 0, 139, 0.1);
      }

      .source-item a {
        color: var(--ralph-pink);
        text-decoration: none;
        font-weight: 600;
        margin-left: 8px;
      }

      .source-item a:hover {
        text-decoration: underline;
      }

      .search-suggestion {
        color: #31BDBF;
        cursor: pointer;
        text-decoration: underline;
        font-weight: 600;
        transition: all 0.2s ease;
      }

      .search-suggestion:hover {
        color: #2a9b9e;
        background: rgba(49, 189, 191, 0.1);
        padding: 2px 4px;
        border-radius: 4px;
        text-decoration: none;
      }

      .pov-followup {
        color: var(--ralph-pink);
        cursor: pointer;
        text-decoration: underline;
        font-weight: 600;
      }

      /* Key word highlighting */
      .highlight-orange {
        color: #F16524;
        font-weight: 600;
      }

      .highlight-green {
        color: #44B658;
        font-weight: 600;
      }

      /* Enhanced citation styling */
      .citation.important {
        background: linear-gradient(135deg, #F16524, #FF7B47);
        color: white;
        border-radius: 4px;
        padding: 2px 6px;
        text-decoration: none;
        font-weight: 600;
      }

      .citation.cultural {
        background: linear-gradient(135deg, #44B658, #5DC470);
        color: white;
        border-radius: 4px;
        padding: 2px 6px;
        text-decoration: none;
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div class="sidebar">
      <div class="logo-container">
        <img src="RalphLogosmall.png" alt="Ralph Logo" />
        <h1>MAG CHAT</h1>
      </div>

      <button id="newChatBtn" class="new-chat-btn">
        ✨ New Chat
      </button>

      <button class="collapse-toggle" id="historyToggle">
        <span class="icon">▼</span>
        <span>Chat History</span>
      </button>

      <div class="history-sections" id="historySections">
        <div class="history-list" id="historyList">
          <div class="no-history">No previous conversations</div>
        </div>
        <button id="clearHistoryBtn" class="clear-history-btn">Clear All History</button>
      </div>

      <button class="collapse-toggle collapsed" id="setupToggle">
        <span class="icon">▼</span>
        <span>Setup</span>
      </button>

      <div class="setup-sections collapsed" id="setupSections">
        <div class="section-title">Step 1: Set Admin Auth</div>
        <button id="btnSetAuth">Set Admin Auth</button>
        <div class="status-text">Admin: <span id="adminStatus" class="status-value">not set</span></div>

        <hr class="divider"/>

        <div class="section-title">Step 2: Connect Google Drive</div>
        <a id="authLink" href="#" target="_blank">🌐 Google OAuth (Web)</a>
        <a id="authLinkInstalled" href="#" target="_blank">💻 Google OAuth (Desktop)</a>
        <input id="codeInput" placeholder="Paste authorization code here..." />
        <button id="btnSubmitCode">Submit Code</button>

        <div class="status-text">Drive: <span id="driveStatus" class="status-value">not connected</span></div>
        <div class="status-text">Folders: <span id="folderStatus" class="status-value">0 configured</span></div>

        <hr class="divider"/>

        <div class="section-title">Step 3: Sync</div>
        <button id="btnSync" disabled>🔄 Sync Google Drive</button>
        <small class="helper-text">Authorize once, submit the code, then sync to index your content.</small>

        <div class="status-text" style="margin-top:16px">Status: <span id="status" class="status-value">Idle</span></div>
      </div>
    </div>
    <div class="main">
      <div class="chat-container">
        <div id="messages" class="messages"></div>
        <div class="input">
          <textarea id="input" placeholder="Ask about issues, quotes, authors, pages..."></textarea>
          <button id="send">Send</button>
        </div>
      </div>
      <div class="sources-panel" id="sources"></div>
    </div>
    <script>
      const messagesEl = document.getElementById('messages');
      const sourcesEl = document.getElementById('sources');
      const inputEl = document.getElementById('input');
      const sendBtn = document.getElementById('send');

      // Chat history management
      let currentConversation = { id: null, messages: [], title: '' };
      const HISTORY_STORAGE_KEY = 'ralphmagchat_history';

      // Store current sources for citation linking
      let currentSources = [];
      let lastUserQuestion = '';

      // Store sources per message and track the pinned (latest) assistant index
      let messageSourcesMap = new Map(); // messageIndex -> {cited: [], also: []}
      let messageQuestionMap = new Map(); // assistantMessageIndex -> userQuestion
      let currentMessageIndex = 0;
      let pinnedMessageIndex = null;

      function askRalphsPOV() {
        if (!lastUserQuestion) return;

        // Create a synthesis query that asks for a one paragraph distillation
        const povQuery = `Based on all the search results and content about "${lastUserQuestion}", provide a one paragraph distillation that synthesizes Ralph Magazine's overall perspective, key insights, and editorial stance on this subject.`;

        // Set the input and trigger sending
        inputEl.value = povQuery;
        sendMessage();
      }

      function triggerSearch(keyword) {
        // Set the input field with the clicked keyword and trigger a new search
        inputEl.value = keyword;
        sendMessage();
      }

      function __escapeHTML(s){return s.replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));}

      function formatAnswer(text) {
        // Escape HTML first
        let html = __escapeHTML(text);

        // Format citations [#1] -> clickable links with smart styling
        html = html.replace(/\[#(\d+)\]/g, (match, num) => {
          const source = currentSources.find(s => s.ref === `#${num}`);

          // Determine citation class based on content
          let citationClass = 'citation';
          if (source) {
            const title = (source.title || '').toLowerCase();
            const author = (source.author || '').toLowerCase();

            // Orange for fashion, style, trends (excluding Ralph terms)
            if (title.includes('fashion') || title.includes('style') || title.includes('trend')) {
              citationClass += ' important';
            }
            // Green for culture, art, creative, music, design, interviews
            else if (title.includes('culture') || title.includes('art') || title.includes('creative') ||
                     title.includes('music') || title.includes('design') || title.includes('interview')) {
              citationClass += ' cultural';
            }
          }

          if (source && source.url) {
            // If source has URL, link directly to it; add data-ref for hover highlight
            return `<a href="${source.url}" target="_blank" class="${citationClass}" data-ref="#${num}">[#${num}]</a>`;
          } else {
            // Otherwise make it scroll to the source in the panel
            return `<a href="#source-${num}" onclick="document.getElementById('source-${num}')?.scrollIntoView({behavior: 'smooth', block: 'center'}); document.getElementById('source-${num}')?.classList.add('highlight'); setTimeout(() => document.getElementById('source-${num}')?.classList.remove('highlight'), 2000); return false;" class="${citationClass}" data-ref="#${num}">[#${num}]</a>`;
          }
        });

        // Make search suggestion keywords clickable FIRST (before word highlighting)
        html = html.replace(/(For more specifics,?\s*try searching:\s*)([^\n]+)/gi, (match, prefix, suggestions) => {
          // Aggressively clean the suggestions text of all HTML artifacts
          let cleanSuggestions = suggestions
            .replace(/['"]/g, '')           // Remove quotes
            .replace(/\)"/g, '')            // Remove )"
            .replace(/>\s*</g, ' ')         // Remove tag boundaries
            .replace(/<[^>]*>/g, '')        // Remove all HTML tags
            .replace(/&quot;/g, '')         // Remove HTML entities
            .replace(/&[a-z]+;/g, '')       // Remove other entities
            .trim();

          // Extract just the actual keywords using a more robust approach
          const keywordMatches = cleanSuggestions.match(/[a-zA-Z][a-zA-Z\s]+?(?:,| or |$)/g) || [];

          const keywords = keywordMatches.map(k =>
            k.replace(/,$/g, '').replace(/\s+or$/g, '').trim()
          ).filter(Boolean);

          if (keywords.length === 0) {
            // Fallback: just return the original text without processing
            return match;
          }

          // Make each keyword clickable (CSP-safe: use data-keyword + delegated handler)
          const clickableKeywords = keywords.map(keyword => {
            const cleanKeyword = keyword.trim();
            return `<span class=\"search-suggestion\" data-keyword=\"${cleanKeyword}\">${cleanKeyword}</span>`;
          }).join(', ').replace(/, ([^,]+)$/, ' or $1');

          return prefix + clickableKeywords;
        });

        // (Removed) Do not inject POV follow-up line.

        // Highlight key words with strategic colors (avoiding existing HTML tags and clickable elements)
        function highlightTermsAvoidingHTML(text, terms, className) {
          // Skip highlighting if the text contains onclick handlers to protect clickable elements
          if (text.includes('onclick=')) {
            return text;
          }

          // Split text by HTML tags to process only text content
          const parts = text.split(/(<[^>]*>)/);
          let insideClickableSpan = false;

          for (let i = 0; i < parts.length; i++) {
            if (i % 2 === 1) {
              // This is an HTML tag
              if (parts[i].includes('onclick=') || parts[i].includes('class="pov-followup"') || parts[i].includes('class="search-suggestion"')) {
                insideClickableSpan = parts[i].startsWith('<span');
              } else if (parts[i] === '</span>' && insideClickableSpan) {
                insideClickableSpan = false;
              }
            } else {
              // This is text content - only process if not inside a clickable span
              if (parts[i] && !insideClickableSpan) {
                terms.forEach(term => {
                  const regex = new RegExp(`\\b(${term})\\b`, 'gi');
                  parts[i] = parts[i].replace(regex, `<span class="${className}">$1</span>`);
                });
              }
            }
          }

          return parts.join('');
        }

        // Orange for fashion terms (excluding Ralph brand terms)
        const orangeTerms = ['fashion', 'style', 'trend', 'trends', 'designer', 'brand', 'runway', 'collection', 'collections', 'luxury', 'editorial', 'magazine'];
        html = highlightTermsAvoidingHTML(html, orangeTerms, 'highlight-orange');

        // Green for culture & creative terms
        const greenTerms = ['culture', 'cultural', 'art', 'artist', 'creative', 'music', 'design', 'aesthetic', 'innovation', 'contemporary', 'modern', 'avant-garde'];
        html = highlightTermsAvoidingHTML(html, greenTerms, 'highlight-green');

        // Highlight engaging opening phrases (keeping Ralph brand pink) - using HTML-aware approach
        const openingPhrases = ['Found something!', 'Ralph\'s covered this!', 'Ralph\'s explored'];
        html = highlightTermsAvoidingHTML(html, openingPhrases, 'highlight-orange');

        // Highlight cultural insights and creative discoveries
        const creativeTerms = ['cultural impact', 'creative process', 'artistic vision', 'aesthetic approach', 'innovative design'];
        html = highlightTermsAvoidingHTML(html, creativeTerms, 'highlight-green');

        // Detect and format bullet points (lines starting with - or •)
        const lines = html.split('\n');
        let inList = false;
        const formatted = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();

          if (line.match(/^[-•]\s+/)) {
            if (!inList) {
              formatted.push('<ul>');
              inList = true;
            }
            const content = line.replace(/^[-•]\s+/, '');
            formatted.push(`<li><span class="quote">${content}</span></li>`);
          } else if (inList && line === '') {
            // Keep empty lines in lists
            continue;
          } else {
            if (inList) {
              formatted.push('</ul>');
              inList = false;
            }

            if (line) {
              // Check if it's the first substantial line (summary)
              if (formatted.length === 0 || (formatted.length === 1 && formatted[0] === '')) {
                formatted.push(`<div class="summary">${line}</div>`);
              } else if (line.includes('suggest') || line.includes('clarif') || line.includes('follow-up')) {
                // Detect clarifying questions
                formatted.push(`<div class="clarifier">${line}</div>`);
              } else {
                formatted.push(`<p>${line}</p>`);
              }
            } else {
              // Skip empty lines to reduce spacing
              continue;
            }
          }
        }

        if (inList) {
          formatted.push('</ul>');
        }

        return formatted.join('');
      }

      // Ensure global access + delegated click handlers for CSP safety
      window.askRalphsPOV = askRalphsPOV;
      window.triggerSearch = triggerSearch;
      document.addEventListener('click', (e) => {
        const t = e.target;
        if (!t || !t.classList) return;
        if (t.classList.contains('pov-followup')) {
          e.preventDefault();
          askRalphsPOV();
        } else if (t.classList.contains('search-suggestion')) {
          e.preventDefault();
          const kw = (t.getAttribute('data-keyword') || t.textContent || '').trim();
          if (kw) triggerSearch(kw);
        } else if (t.classList.contains('history-rerun')) {
          e.preventDefault();
          const conversationId = parseInt(t.getAttribute('data-id'));
          if (conversationId) rerunHistory(conversationId);
        } else if (t.classList.contains('history-item') || t.closest('.history-item')) {
          const historyItem = t.classList.contains('history-item') ? t : t.closest('.history-item');
          const conversationId = parseInt(historyItem.getAttribute('data-id'));
          if (conversationId) loadConversation(conversationId);
        }
      });

      // Hover highlight for citations
      messagesEl.addEventListener('mouseover', (e) => {
        const a = e.target.closest('a.citation');
        if (!a) return;
        const ref = (a.getAttribute('data-ref') || '').replace('#','');
        const el = document.getElementById('source-' + ref);
        if (el) el.classList.add('highlight');
      });
      messagesEl.addEventListener('mouseout', (e) => {
        const a = e.target.closest('a.citation');
        if (!a) return;
        const ref = (a.getAttribute('data-ref') || '').replace('#','');
        const el = document.getElementById('source-' + ref);
        if (el) el.classList.remove('highlight');
      });

      function saveConversation() {
        if (currentConversation.messages.length === 0) return;

        const history = JSON.parse(localStorage.getItem(HISTORY_STORAGE_KEY) || '[]');
        const existingIndex = history.findIndex(conv => conv.id === currentConversation.id);

        // Include sources data when saving
        const conversationToSave = {
          ...currentConversation,
          timestamp: Date.now(),
          sourcesMap: Object.fromEntries(messageSourcesMap), // Convert Map to object for JSON
          questionMap: Object.fromEntries(messageQuestionMap) // Save question mapping too
        };

        if (existingIndex >= 0) {
          history[existingIndex] = conversationToSave;
        } else {
          currentConversation.id = Date.now();
          conversationToSave.id = currentConversation.id;
          conversationToSave.timestamp = currentConversation.id;
          history.unshift(conversationToSave);
        }

        // Keep only last 50 conversations
        if (history.length > 50) history.splice(50);

        localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
        refreshHistory();
      }

      function generateTitle(firstMessage) {
        const words = firstMessage.split(' ').slice(0, 6);
        return words.join(' ') + (firstMessage.split(' ').length > 6 ? '...' : '');
      }

      function loadConversation(conversationId) {
        const history = JSON.parse(localStorage.getItem(HISTORY_STORAGE_KEY) || '[]');
        const conversation = history.find(conv => conv.id === conversationId);
        if (!conversation) return;

        // Clear current messages
        messagesEl.innerHTML = '';
        sourcesEl.style.display = 'flex';

        // Reset message tracking for loaded conversation
        messageSourcesMap.clear();
        messageQuestionMap.clear();
        currentMessageIndex = 0;
        currentSources = [];

        // Restore sources data if available
        if (conversation.sourcesMap) {
          messageSourcesMap = new Map(Object.entries(conversation.sourcesMap).map(([k, v]) => [parseInt(k), v]));
        }

        // Restore question mapping if available
        if (conversation.questionMap) {
          messageQuestionMap = new Map(Object.entries(conversation.questionMap).map(([k, v]) => [parseInt(k), v]));
        }

        // Load conversation messages
        currentConversation = { ...conversation };
        conversation.messages.forEach(msg => {
          const msgEl = addMessage(msg.role, '');
          if (msg.role === 'assistant') {
            msgEl.innerHTML = formatAnswer(msg.content);
          } else {
            msgEl.textContent = msg.content;
          }
        });

        // Find the last assistant message and pin its sources
        const assistantMessages = conversation.messages
          .map((msg, idx) => ({ msg, idx }))
          .filter(({ msg }) => msg.role === 'assistant');

        if (assistantMessages.length > 0) {
          const lastAssistantIndex = assistantMessages[assistantMessages.length - 1].idx;
          pinnedMessageIndex = lastAssistantIndex;

          // Set lastUserQuestion from the question mapping for the pinned message
          const questionForPinnedMessage = messageQuestionMap.get(lastAssistantIndex);
          if (questionForPinnedMessage) {
            lastUserQuestion = questionForPinnedMessage;
          } else {
            // Fallback to last user message if mapping doesn't exist
            const userMessages = conversation.messages.filter(msg => msg.role === 'user');
            if (userMessages.length > 0) {
              lastUserQuestion = userMessages[userMessages.length - 1].content;
            }
          }

          updatePinnedSources();
        } else {
          initializeSourcesPanel();
        }
      }

      function rerunHistory(conversationId) {
        const history = JSON.parse(localStorage.getItem(HISTORY_STORAGE_KEY) || '[]');
        const conversation = history.find(conv => conv.id === conversationId);
        if (!conversation) return;
        // Find the last user message; fallback to first
        const lastUser = [...conversation.messages].reverse().find(m => m.role === 'user') || conversation.messages.find(m => m.role === 'user');
        if (lastUser && lastUser.content) {
          inputEl.value = lastUser.content;
          sendMessage();
        }
      }
      // Expose globally so inline handler works
      window.rerunHistory = rerunHistory;

      function refreshHistory() {
        const historyList = document.getElementById('historyList');
        const history = JSON.parse(localStorage.getItem(HISTORY_STORAGE_KEY) || '[]');

        if (history.length === 0) {
          historyList.innerHTML = '<div class="no-history">No previous conversations</div>';
          return;
        }

        historyList.innerHTML = history.map(conv => {
          const date = new Date(conv.timestamp);
          const timeStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          return `
            <div class=\"history-item\" data-id=\"${conv.id}\" title=\"Re-run this search\">
              <div>
                <div class=\"history-item-title\">${conv.title || 'Untitled'}</div>
                <div class=\"history-item-time\">${timeStr}</div>
              </div>
              <div class=\"history-actions\">
                <button class=\"history-rerun\" title=\"Re-run\" data-id=\"${conv.id}\">↻</button>
              </div>
            </div>
          `;
        }).join('');
      }

      function clearAllHistory() {
        if (confirm('Are you sure you want to clear all chat history?')) {
          localStorage.removeItem(HISTORY_STORAGE_KEY);
          refreshHistory();
        }
      }

      function startNewConversation() {
        // Save current conversation if it has messages
        if (currentConversation.messages.length > 0) {
          saveConversation();
        }

        // Start fresh
        currentConversation = { id: null, messages: [], title: '' };
        messagesEl.innerHTML = '';
        initializeSourcesPanel();

        // Reset sources and message tracking for new conversation
        messageSourcesMap.clear();
        messageQuestionMap.clear();
        currentMessageIndex = 0;
        currentSources = [];
      }
      const statusEl = document.getElementById('status');
      const authLink = document.getElementById('authLink');

      let adminAuth = localStorage.getItem('adminAuth') || '';
      function authHeaders() {
        return adminAuth ? { 'Authorization': 'Basic ' + adminAuth } : {};
      }

      async function initAuth() {
        try {
          const r = await fetch('/api/sync/auth-url', { headers: authHeaders() });
          const j = await r.json();
          authLink.href = j.url;
        } catch (e) { console.error(e); authLink.removeAttribute('href'); }
        try {
          const r2 = await fetch('/api/sync/auth-url?flow=installed', { headers: authHeaders() });
          const j2 = await r2.json();
          document.getElementById('authLinkInstalled').href = j2.url;
        } catch (e) { console.error(e); }
      }

      // Initialize based on content source mode
      (async function initializeApp(){
        try {
          const cfg = await fetch('/api/config').then(r=>r.json());
          const isPdfMode = (cfg.contentSource || 'PDFS').toUpperCase() === 'PDFS';

          if (isPdfMode) {
            // Hide Drive-specific controls if present
            ['btnSetAuth','authLink','authLinkInstalled','btnSubmitCode','driveStatus','folderStatus'].forEach(id=>{
              const el = document.getElementById(id);
              if (el) el.style.display = 'none';
            });
            // Hide entire Setup dropdown (not needed in PDF mode)
            const setupToggle = document.getElementById('setupToggle');
            const setupSections = document.getElementById('setupSections');
            if (setupToggle) setupToggle.style.display = 'none';
            if (setupSections) setupSections.style.display = 'none';

            const sidebar = document.querySelector('.sidebar');
            if (sidebar && !document.getElementById('pdfAutoSync')) {
              // Create loading UI for auto-sync
              const loadingContainer = document.createElement('div');
              loadingContainer.id = 'pdfAutoSync';
              loadingContainer.className = 'loading-container';
              loadingContainer.innerHTML = `
                <div class="loading-text">Preparing Issue content...</div>
                <div class="loading-bar">
                  <div class="loading-progress" id="syncProgress"></div>
                </div>
                <div id="syncStatus" class="status-text">Scanning: ${cfg.pdfsDir || '(set PDFS_DIR)'}</div>
              `;
              // Insert after the logo-container, before the New Chat button
              const logoContainer = sidebar.querySelector('.logo-container');
              const newChatBtn = sidebar.querySelector('#newChatBtn');
              if (logoContainer && newChatBtn) {
                sidebar.insertBefore(loadingContainer, newChatBtn);
              } else {
                sidebar.insertBefore(loadingContainer, sidebar.firstChild.nextSibling);
              }

              // Auto-sync on page load
              autoSyncPdfs();
            }

            // Load covers and render a row of clickable thumbnails
            try {
              const covers = await fetch('/api/covers').then(r=>r.json());
              if (covers && Array.isArray(covers.items) && covers.items.length) {
                // Add spacer to push covers to bottom
                const sidebar = document.querySelector('.sidebar');
                const spacer = document.createElement('div');
                spacer.className = 'sidebar-spacer';
                sidebar.appendChild(spacer);

                const row = document.createElement('div');
                row.className = 'covers-row';
                covers.items.slice(0,3).forEach(item => {
                  const a = document.createElement('a');
                  a.href = item.pdfUrl || '#';
                  a.target = '_blank';
                  a.rel = 'noopener';
                  const img = document.createElement('img');
                  img.src = item.coverUrl;
                  img.alt = item.name || 'Cover';
                  img.className = 'cover-thumb';
                  a.appendChild(img);
                  row.appendChild(a);
                });
                // Append at very bottom of sidebar after spacer
                sidebar.appendChild(row);
              }
            } catch {}
          } else {
            // Google Drive mode - initialize auth and status
            initAuth();
            refreshStatus();
          }
        } catch {}
      })();

      async function refreshStatus() {
        const adminEl = document.getElementById('adminStatus');
        const driveEl = document.getElementById('driveStatus');
        const folderEl = document.getElementById('folderStatus');
        const syncBtn = document.getElementById('btnSync');
        try {
          const r = await fetch('/api/sync/status', { headers: authHeaders() });
          if (r.status === 401 || r.status === 503) {
            adminEl.textContent = 'not set';
            driveEl.textContent = 'unknown (set admin first)';
            folderEl.textContent = 'unknown';
            syncBtn.disabled = true;
            return;
          }
          const j = await r.json();
          adminEl.textContent = 'set';
          driveEl.textContent = j.hasToken ? 'connected' : 'not connected';
          folderEl.textContent = j.folderIds && j.folderIds.length ? `${j.folderIds.length} configured` : '0 configured';
          syncBtn.disabled = !j.canSync;
        } catch (e) {
          adminEl.textContent = 'error';
          syncBtn.disabled = true;
        }
      }

      document.getElementById('btnSetAuth').onclick = async () => {
        const u = prompt('Admin username:');
        if (!u) return;
        const p = prompt('Admin password:');
        if (p == null) return;
        adminAuth = btoa(u + ':' + p);
        localStorage.setItem('adminAuth', adminAuth);
        await initAuth();
        await refreshStatus();
        statusEl.textContent = 'Admin auth set (saved locally)';
      };

      document.getElementById('btnSubmitCode').onclick = async () => {
        const code = document.getElementById('codeInput').value.trim();
        if (!code) return alert('Paste the authorization code first');
        statusEl.textContent = 'Submitting code...';
        try {
          const r = await fetch('/api/sync/oauth2/callback', { method:'POST', headers: { 'Content-Type': 'application/json', ...authHeaders() }, body: JSON.stringify({ code }) });
          const j = await r.json();
          if (!r.ok) throw new Error(j.error || 'Auth code failed');
          statusEl.textContent = 'Drive token saved';
          document.getElementById('codeInput').value='';
          await refreshStatus();
        } catch (e) {
          statusEl.textContent = 'Failed to save token';
          alert(e.message);
        }
      };

      document.getElementById('btnSync').onclick = async () => {
        statusEl.textContent = 'Syncing...';
        try {
          const r = await fetch('/api/sync/google-drive', { method: 'POST', headers: { 'Content-Type': 'application/json', ...authHeaders() } });
          const j = await r.json();
          if (!r.ok) throw new Error(j.error || 'Sync error');
          const skipped = j.files_skipped ? `, skipped ${j.files_skipped}` : '';
          statusEl.textContent = `Sync complete: processed ${j.files_processed}${skipped}`;
          await refreshStatus();
        } catch (e) {
          statusEl.textContent = 'Sync failed';
          alert(e.message);
        }
      };

      function addMessage(role, text) {
        const d = document.createElement('div');
        d.className = 'msg ' + role;
        d.textContent = text;
        d.setAttribute('data-message-index', currentMessageIndex);
        messagesEl.appendChild(d);
        messagesEl.scrollTop = messagesEl.scrollHeight;
        currentMessageIndex++;
        return d;
      }

      // Handle Enter key in textarea
      inputEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      async function sendMessage() {
        const q = inputEl.value.trim();
        if (!q) return;
        lastUserQuestion = q; // Store for POV follow-up
        inputEl.value = '';
        addMessage('user', q);
        const a = addMessage('assistant', '');
        pinnedMessageIndex = currentMessageIndex - 1; // pin new assistant message's sources
        messageQuestionMap.set(pinnedMessageIndex, q); // link this assistant message to its question
        // Add inline reading animation bar inside the assistant bubble
        const reading = document.createElement('div');
        reading.className = 'reading-container';
        reading.innerHTML = '<div class="reading-progress"></div>';
        a.prepend(reading);
        sourcesEl.innerHTML = `
          <h3 style="color: var(--ralph-pink);">📎 Cited Sources</h3>
          <div class="status-text" style="color: #999; font-style: italic; text-align: center; padding: 20px;">
            Searching for relevant sources...
          </div>
          <h3 style="color: #44B658;">💡 Also Relevant</h3>
          <div class="status-text" style="color: #999; font-style: italic; text-align: center; padding: 20px;">
            Additional references will appear here
          </div>
        `;
        sourcesEl.style.display = 'flex';
        currentSources = []; // Reset sources for new query

        const r = await fetch('/api/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: q }) });
        if (!r.ok) {
          const j = await r.json().catch(() => ({}));
          a.textContent = j.error || 'Error';
          return;
        }
        const reader = r.body.getReader();
        const dec = new TextDecoder();
        // Accumulate assistant text to enable post-stream formatting
        let accumulatedText = '';
        function __escapeHTML(s){return s.replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));}
        function __highlight(text, query){
          const terms = (query.toLowerCase().match(/[a-z0-9]+/g) || []).filter(t=>t.length>1);
          if(!terms.length) return __escapeHTML(text);
          const re = new RegExp('(' + terms.map(t=>t.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')).join('|') + ')','gi');
          return __escapeHTML(text).replace(re,'<mark>$1</mark>');
        }

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunk = dec.decode(value);
          for (const line of chunk.split('\n')) {
            if (!line.startsWith('data: ')) continue;
            const evt = JSON.parse(line.slice(6));
            if (evt.type === 'text') {
              accumulatedText += evt.delta;
              a.textContent = accumulatedText; // Show raw text while streaming
            } else if (evt.type === 'sources') {
              // Remove reading bar with a quick fade
              if (reading && reading.parentNode) { reading.classList.add('reading-hide'); setTimeout(() => reading.remove(), 170); }
              // Store sources and render pinned column for this reply
              currentSources = [...(evt.cited || []), ...(evt.also || [])];
              const assistantMsgIndex = pinnedMessageIndex;
              messageSourcesMap.set(assistantMsgIndex, { cited: evt.cited || [], also: evt.also || [] });
              updatePinnedSources();
            } else if (evt.type === 'error') {
              a.textContent = '[Error] ' + evt.error;
            }
          }
        }

        // Apply formatted styling when streaming is complete
        if (accumulatedText) {
          if (reading && reading.parentNode) { reading.classList.add('reading-hide'); setTimeout(() => reading.remove(), 170); }
          a.innerHTML = formatAnswer(accumulatedText);
        }

        // Save conversation to history
        currentConversation.messages.push(
          { role: 'user', content: q },
          { role: 'assistant', content: accumulatedText || '[Error]' }
        );

        // Set title from first user message
        if (currentConversation.messages.length === 2 && !currentConversation.title) {
          currentConversation.title = generateTitle(q);
        }

        saveConversation();
      }

      // Auto-sync PDFs function
      async function autoSyncPdfs() {
        const progressBar = document.getElementById('syncProgress');
        const statusEl = document.getElementById('syncStatus');
        const loadingText = document.querySelector('.loading-text');

        try {
          // Step 1: Check PDF directory status
          progressBar.style.width = '20%';
          statusEl.textContent = 'Checking Issue directory...';

          const statusResponse = await fetch('/api/sync-pdfs/status');
          const statusData = await statusResponse.json();

          if (statusData.files_detected === 0) {
            loadingText.textContent = 'No Issues found';
            statusEl.textContent = `Directory: ${statusData.dir} (empty)`;
            progressBar.style.width = '100%';
            setTimeout(() => {
              const container = document.getElementById('pdfAutoSync');
              if (container) {
                container.innerHTML = '<div class="sync-complete">No Issues to index. Add Issues to the directory and refresh.</div>';
              }
            }, 1000);
            return;
          }

          // Step 2: Start sync process
          progressBar.style.width = '40%';
          loadingText.textContent = `Processing ${statusData.files_detected} Issue${statusData.files_detected > 1 ? 's' : ''}...`;
          statusEl.textContent = 'Extracting text and generating embeddings...';

          const syncResponse = await fetch('/api/sync-pdfs/run', { method: 'POST' });
          const syncData = await syncResponse.json();

          if (!syncResponse.ok) {
            throw new Error(syncData.error || 'Sync failed');
          }

          // Step 3: Complete
          progressBar.style.width = '100%';
          loadingText.textContent = 'Issue indexing complete!';
          statusEl.textContent = `Processed ${syncData.files_processed} files${syncData.files_skipped ? `, skipped ${syncData.files_skipped}` : ''}`;

          // Show completion message
          setTimeout(() => {
            const container = document.getElementById('pdfAutoSync');
            if (container) {
              // Total files = newly processed + skipped (already indexed)
              const totalFiles = syncData.files_processed + (syncData.files_skipped || 0);
              const message = totalFiles === 0
                ? 'Issue sync complete!<br><small>No Issues found - add Issues to the directory to get started</small>'
                : `Ready to explore ${totalFiles} Issue${totalFiles > 1 ? 's' : ''}!<br><small>Chat is ready for questions</small>`;

              container.innerHTML = `<div class="sync-complete">${message}</div>`;
            }
          }, 2000);

        } catch (error) {
          console.error('Auto-sync failed:', error);
          loadingText.textContent = 'Sync failed';
          statusEl.textContent = error.message;
          progressBar.style.width = '100%';
          progressBar.style.background = '#ff6b6b';

          // Show error message
          setTimeout(() => {
            const container = document.getElementById('pdfAutoSync');
            if (container) {
              container.innerHTML = `
                <div class="sync-complete" style="background: rgba(255,107,107,0.2);">
                  ❌ Sync failed: ${error.message}
                  <br><small>Check console for details</small>
                </div>
              `;
            }
          }, 2000);
        }
      }

      // Contextual sources functionality
      function getVisibleMessages() {
        const containerRect = messagesEl.getBoundingClientRect();
        const messages = messagesEl.querySelectorAll('.msg');
        const visibleMessages = [];

        messages.forEach((msg, index) => {
          const msgRect = msg.getBoundingClientRect();
          // Check if message is at least partially visible
          if (msgRect.bottom > containerRect.top && msgRect.top < containerRect.bottom) {
            const messageIndex = parseInt(msg.getAttribute('data-message-index'));
            if (!isNaN(messageIndex)) {
              visibleMessages.push(messageIndex);
            }
          }
        });

        return visibleMessages;
      }

      function renderSourcesList(title, sources) {
        if (!sources || !sources.length) return '';

        const items = sources.map(s => {
          // Build display parts with better page handling
          const parts = [
            s.ref,
            s.title || 'Untitled',
            s.author ? `by ${s.author}` : null,
            s.issue ? `Issue ${s.issue}` : null,
            (s.page || (s.meta && s.meta.page)) ? `p.${s.page || s.meta.page}` : null
          ].filter(Boolean).join(' · ');

          // Use server-provided URL directly (already includes #page for PDFs)
          let link = '';
          if (s.url) {
            link = `<a href=\"${s.url}\" target=\"_blank\">Open</a>`;
          }

          // Add ID for scrolling to source
          return `<div class="source-item" id="source-${s.ref.replace('#', '')}">${parts} ${link}</div>`;
        }).join('');

        // Color-coded section headers
        const coloredTitle = title.includes('Cited')
          ? `<h3 style="color: #F16524;">${title}</h3>`
          : `<h3 style="color: #44B658;">${title}</h3>`;

        return coloredTitle + items;
      }

      let __lastSourcesKey = '';
      function getTopicLabel() {
        if (lastUserQuestion && lastUserQuestion.trim()) {
          const t = lastUserQuestion.trim();
          return t.length > 24 ? t.slice(0, 24) + '…' : t;
        }
        return 'this topic';
      }

      function initializeSourcesPanel() {
        sourcesEl.innerHTML = `
          <h3 style="color: var(--ralph-pink);">📎 Cited Sources</h3>
          <div class="status-text" style="color: #999; font-style: italic; text-align: center; padding: 20px;">
            Sources will appear here after your first search
          </div>
          <h3 style="color: #44B658;">💡 Also Relevant</h3>
          <div class="status-text" style="color: #999; font-style: italic; text-align: center; padding: 20px;">
            Additional references will be shown here
          </div>
        `;
        sourcesEl.style.display = 'flex';
      }

      function updatePinnedSources() {
        const topic = getTopicLabel();
        const entry = pinnedMessageIndex != null ? messageSourcesMap.get(pinnedMessageIndex) : null;
        const citedList = entry ? entry.cited : [];
        const alsoList = entry ? entry.also : [];
        const cited = renderSourcesList(`📎 Cited Sources ("${topic}")`, citedList);
        const also = renderSourcesList('💡 Also Relevant', alsoList);
        sourcesEl.classList.add('fading');
        requestAnimationFrame(() => {
          sourcesEl.innerHTML = (cited || '<h3>📎 Cited Sources</h3><div class="status-text">No sources yet</div>') + (also || '');
          sourcesEl.style.display = 'flex';
          const items = Array.from(sourcesEl.querySelectorAll('.source-item'));
          items.forEach((el, idx) => {
            el.classList.add('enter');
            setTimeout(() => el.classList.add('enter-active'), 10 + idx * 20);
            setTimeout(() => el.classList.remove('enter', 'enter-active'), 300);
          });
          setTimeout(() => sourcesEl.classList.remove('fading'), 120);
        });
      }

      // Scroll-driven source updates: change sources based on visible assistant message
      function updateSourcesBasedOnScroll() {
        const visibleMessages = getVisibleMessages();
        if (visibleMessages.length === 0) return;

        // Find the most visible assistant message
        let bestAssistantIndex = null;
        let bestIntersection = 0;

        visibleMessages.forEach(msgIndex => {
          const msgEl = messagesEl.querySelector(`[data-message-index="${msgIndex}"]`);
          if (msgEl && msgEl.classList.contains('assistant')) {
            const rect = msgEl.getBoundingClientRect();
            const containerRect = messagesEl.getBoundingClientRect();

            // Calculate how much of the message is visible
            const visibleTop = Math.max(rect.top, containerRect.top);
            const visibleBottom = Math.min(rect.bottom, containerRect.bottom);
            const visibleHeight = Math.max(0, visibleBottom - visibleTop);
            const totalHeight = rect.height;
            const intersection = visibleHeight / totalHeight;

            if (intersection > bestIntersection) {
              bestIntersection = intersection;
              bestAssistantIndex = msgIndex;
            }
          }
        });

        // Update pinned sources if we found a different assistant message
        if (bestAssistantIndex !== null && bestAssistantIndex !== pinnedMessageIndex) {
          pinnedMessageIndex = bestAssistantIndex;

          // Update lastUserQuestion to match the visible assistant message
          const questionForThisMessage = messageQuestionMap.get(bestAssistantIndex);
          if (questionForThisMessage) {
            lastUserQuestion = questionForThisMessage;
          }

          updatePinnedSources();
        }
      }

      // Throttled scroll handler
      let scrollTimeout = null;
      messagesEl.addEventListener('scroll', () => {
        if (scrollTimeout) clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(updateSourcesBasedOnScroll, 150);
      });

      // Setup toggle functionality
      document.getElementById('setupToggle').onclick = () => {
        const setupSections = document.getElementById('setupSections');
        const toggleBtn = document.getElementById('setupToggle');

        setupSections.classList.toggle('collapsed');
        toggleBtn.classList.toggle('collapsed');
      };

      // History toggle functionality
      document.getElementById('historyToggle').onclick = () => {
        const historySections = document.getElementById('historySections');
        const toggleBtn = document.getElementById('historyToggle');

        historySections.classList.toggle('collapsed');
        toggleBtn.classList.toggle('collapsed');
      };

      // Clear history button
      document.getElementById('clearHistoryBtn').onclick = clearAllHistory;

      // New chat button
      document.getElementById('newChatBtn').onclick = startNewConversation;

      // Connect button click to sendMessage function
      sendBtn.onclick = sendMessage;

      // Initialize history and sources panel on page load
      refreshHistory();
      initializeSourcesPanel();
    </script>
  </body>
  </html>
